# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Create New GEDI Model Object (Internal)
#'
#' Constructs the C++ GEDI model object and returns an external pointer.
#' This function is called internally by the R6 GEDI class during model setup
#' and should not be called directly by users.
#'
#' @param params List containing initialized parameter matrices:
#'   \itemize{
#'     \item Bi: List of cell projection matrices (K x Ni) for each sample
#'     \item Qi: List of sample-specific metagene matrices (J x K)
#'     \item si, oi: Cell and sample-specific offset vectors
#'     \item o: Global gene offset vector (length J)
#'     \item Z: Shared metagene matrix (J x K)
#'     \item U, S, D: SVD components and scaling factors
#'     \item sigma2: Initial variance estimate
#'     \item A: Pathway-latent factor connection matrix (if C provided)
#'     \item Rk, Ro: Sample covariate effect matrices (if H provided)
#'   }
#' @param aux List containing auxiliary variables and dimensions:
#'   \itemize{
#'     \item J, N, K, P, L: Dimensions (genes, cells, factors, pathways, covariates)
#'     \item numSamples: Number of samples
#'     \item obs.type: Observation type ("M", "M_paired", "Y", or "X")
#'     \item mode: Normalization mode ("Bl2" or "Bsphere")
#'     \item orthoZ, adjustD, is_si_fixed: Boolean flags
#'     \item C, H: Prior matrices (gene pathways, sample covariates)
#'     \item diag_K, J_vec, Ni_vec, Ni: Dimension vectors
#'     \item ZDBi, QiDBi: Precomputed product matrices
#'   }
#' @param target List containing target data matrices:
#'   \itemize{
#'     \item Yi: Log-transformed expression by sample (computed by C++ if empty)
#'     \item Mi: Raw count matrix by sample (for obs.type = "M")
#'     \item M1i, M2i: Paired count matrices (for obs.type = "M_paired")
#'     \item Xi: Binary indicator matrix (for obs.type = "X")
#'   }
#' @param hyperparams List containing hyperparameters for regularization:
#'   \itemize{
#'     \item S_Qi, S_oi, S_Z, S_A, S_R: Shrinkage parameters
#'     \item S_Qi_mean, S_oi_mean, S_si, S_o: Mean shrinkage parameters
#'     \item o_0, si_0: Prior mean values
#'     \item O: Random matrix for rSVD initialization
#'   }
#' @param verbose Integer verbosity level (0=silent, 1=info, 2=debug, 4=timing)
#' @param num_threads Number of OpenMP threads (0=auto, uses all available)
#'
#' @return External pointer (SEXP) to C++ GEDI object
#'
#' @details
#' This function creates a stateful C++ GEDI object that stores all model parameters
#' and data. The C++ object performs all heavy computation, while the R6 wrapper
#' remains lightweight (~1 KB). Memory-efficient design: if Yi is not provided,
#' C++ computes it from raw counts M, eliminating duplicate storage in R.
#'
#' The returned external pointer is managed by R's garbage collector and will
#' automatically free the C++ object when no longer referenced.
#'
#' @keywords internal
#' @noRd
GEDI_new <- function(params, aux, target, hyperparams, verbose = 1L, num_threads = 0L) {
    .Call(`_gedi_GEDI_new`, params, aux, target, hyperparams, verbose, num_threads)
}

#' Initialize Latent Variables (Internal)
#'
#' Initializes latent variables Z, Qi, and Bi using randomized SVD on residual
#' expression data. This is the first step in GEDI model fitting and must be
#' called before optimization.
#'
#' @param model_ptr External pointer to C++ GEDI object (from GEDI_new)
#' @param multimodal Logical, if TRUE skips normalization steps for multi-modal
#'   integration (used internally when combining multiple data modalities)
#'
#' @return List containing initialized model state:
#'   \itemize{
#'     \item params: Updated parameter matrices (Z, Qi, Bi, etc.)
#'     \item aux: Auxiliary variables and dimensions
#'     \item hyperparams: Hyperparameters
#'   }
#'
#' @details
#' Initialization procedure:
#' \enumerate{
#'   \item Solve for initial oi (sample-specific offsets)
#'   \item Compute residual Yp after removing o, oi, si effects
#'   \item Perform randomized SVD on Yp to obtain initial Z
#'   \item Initialize Qi = Z for all samples
#'   \item Solve for initial Bi given Z and Qi
#'   \item Normalize B matrices and update auxiliary products (ZDBi, QiDBi)
#' }
#'
#' Uses randomized SVD (rSVD) for computational efficiency with large matrices.
#' The multimodal flag is used internally for advanced integration workflows.
#'
#' @keywords internal
#' @noRd
GEDI_initialize <- function(model_ptr, multimodal = FALSE) {
    .Call(`_gedi_GEDI_initialize`, model_ptr, multimodal)
}

#' Optimize GEDI Model via Block Coordinate Descent (Internal)
#'
#' Performs block coordinate descent optimization to fit the GEDI model.
#' Iteratively updates all model parameters (Bi, Z, Qi, oi, si, o, sigma2)
#' until convergence or maximum iterations reached.
#'
#' @param model_ptr External pointer to initialized C++ GEDI object
#' @param iterations Integer, number of optimization iterations to perform
#' @param track_interval Integer, interval for tracking convergence metrics
#'   (e.g., track_interval=5 tracks every 5th iteration; track_interval=1 tracks all)
#'
#' @return List containing optimized model results:
#'   \itemize{
#'     \item params: Optimized parameter matrices (Z, Bi, Qi, sigma2, etc.)
#'     \item aux: Auxiliary variables and dimensions
#'     \item hyperparams: Updated hyperparameters (o_0, S_o, S_si)
#'     \item tracking: Convergence metrics (dZ, dBi, dQi, sigma2 trajectory)
#'     \item convergence: Summary statistics (iterations, total_time_ms, final_sigma2)
#'   }
#'
#' @details
#' Block coordinate descent iteration:
#' \enumerate{
#'   \item Solve Bi for all samples (parallelized with OpenMP)
#'   \item Normalize B matrices
#'   \item Solve Z (orthogonal or regular, depending on orthoZ flag)
#'   \item Solve Qi for all samples (parallelized)
#'   \item Solve oi, si, o (offset parameters)
#'   \item Update Yi from raw counts M (for count data)
#'   \item Solve sigma2 (variance parameter)
#'   \item Update hyperpriors (o_0, S_o, S_si)
#'   \item Solve A, Rk, Ro (if priors C or H are provided)
#'   \item Track convergence metrics at specified intervals
#' }
#'
#' OpenMP parallelization is automatically enabled if available. Progress and
#' timing information printed based on verbosity level.
#'
#' @keywords internal
#' @noRd
GEDI_optimize <- function(model_ptr, iterations, track_interval = 5L) {
    .Call(`_gedi_GEDI_optimize`, model_ptr, iterations, track_interval)
}

#' Train GEDI Model (Initialize + Optimize) (Internal)
#'
#' Convenience function that performs both initialization and optimization in a
#' single call. Equivalent to calling GEDI_initialize() followed by GEDI_optimize().
#'
#' @param model_ptr External pointer to C++ GEDI object (from GEDI_new)
#' @param iterations Integer, number of optimization iterations to perform
#' @param track_interval Integer, interval for tracking convergence metrics
#' @param multimodal Logical, if TRUE skips normalization during initialization
#'   (for multi-modal integration workflows)
#'
#' @return List containing trained model results (same format as GEDI_optimize):
#'   \itemize{
#'     \item params: Optimized parameter matrices
#'     \item aux: Auxiliary variables
#'     \item hyperparams: Updated hyperparameters
#'     \item tracking: Convergence metrics
#'     \item convergence: Summary statistics
#'   }
#'
#' @details
#' This is the recommended way to fit a GEDI model in a single step. Internally:
#' \enumerate{
#'   \item Calls initialize() to set up latent variables via rSVD
#'   \item Calls optimize() to perform block coordinate descent
#'   \item Returns the final optimized model state
#' }
#'
#' For more control over the fitting process, use GEDI_initialize() and
#' GEDI_optimize() separately. The multimodal parameter is for advanced use cases.
#'
#' @keywords internal
#' @noRd
GEDI_train <- function(model_ptr, iterations, track_interval = 5L, multimodal = FALSE) {
    .Call(`_gedi_GEDI_train`, model_ptr, iterations, track_interval, multimodal)
}

#' Compute Cell-Specific Scaling Factors (Dense)
#'
#' Calculates column-wise means of a dense expression matrix for hyperparameter initialization.
#' This function computes s_0 = (J_vec^T * Y) / J, where each element represents the mean
#' expression across all genes for each cell. Used internally during GEDI model setup.
#'
#' @param J_vec Vector of ones with length equal to number of genes (J)
#' @param Y Dense log-transformed expression matrix (genes x cells)
#' @param J Number of genes (rows in Y)
#'
#' @return Vector of length N (number of cells) containing cell-specific scaling factors
#'
#' @details
#' This is the dense matrix version used when Y matrix is provided directly.
#' For count matrices (M), use the sparse version \code{compute_s_0()} instead.
#' The function uses BLAS-optimized dense matrix-vector multiplication for efficiency.
#'
#' @keywords internal
#' @noRd
compute_s_0_dense <- function(J_vec, Y, J) {
    .Call(`_gedi_compute_s_0_dense`, J_vec, Y, J)
}

#' Compute Library-Size Normalized Expression (Sparse)
#'
#' Normalizes sparse expression matrix Y by dividing each element by the outer product
#' of J_vec and s_0. This is equivalent to Y / (J_vec * s_0^T).
#'
#' @param Y Sparse expression matrix (genes x cells)
#' @param J_vec Vector of ones with length J (number of genes)
#' @param s_0 Vector of cell-specific scaling factors (length N)
#'
#' @return Sparse matrix Yp with normalized expression values
#'
#' @details
#' Efficiently iterates through non-zero elements only, preserving sparsity.
#' Each Y(i,j) is divided by (J_vec(i) * s_0(j)).
#'
#' @keywords internal
#' @noRd
compute_Yp <- function(Y, J_vec, s_0) {
    .Call(`_gedi_compute_Yp`, Y, J_vec, s_0)
}

#' Compute Gene-Specific Offsets (Dense)
#'
#' Calculates row-wise means of normalized expression matrix for hyperparameter initialization.
#' Computes o_0 = (Yp * N_vec) / N, where each element represents the mean expression
#' of a gene across all cells after library size normalization.
#'
#' @param Yp Normalized dense expression matrix (genes x cells)
#' @param N_vec Vector of ones with length N (number of cells)
#' @param N Number of cells (columns in Yp)
#'
#' @return Vector of length J (number of genes) containing gene-specific offsets
#'
#' @details
#' Used in conjunction with \code{compute_s_0_dense()} and \code{compute_Yp_dense()}
#' to initialize hyperparameters o_0 and s_0 for the GEDI model.
#'
#' @keywords internal
#' @noRd
compute_o_0_dense <- function(Yp, N_vec, N) {
    .Call(`_gedi_compute_o_0_dense`, Yp, N_vec, N)
}

#' Compute Library-Size Normalized Expression (Dense)
#'
#' Computes normalized expression Yp by subtracting the outer product of J_vec and s_0 from Y.
#' This is equivalent to Yp = Y - J_vec * s_0^T.
#'
#' @param Y Dense expression matrix (genes x cells)
#' @param J_vec Vector of ones with length J (number of genes)
#' @param s_0 Vector of cell-specific scaling factors (length N)
#'
#' @return Dense matrix Yp with normalized expression values
#'
#' @details
#' Alternative formulation of library size normalization for dense matrices.
#' Uses \code{noalias()} for efficient in-place subtraction without temporary objects.
#'
#' @keywords internal
#' @noRd
compute_Yp_dense <- function(Y, J_vec, s_0) {
    .Call(`_gedi_compute_Yp_dense`, Y, J_vec, s_0)
}

#' Vector Outer Product
#'
#' Computes the outer product of two vectors: a * b^T, returning a dense matrix.
#' This is used internally for efficient matrix operations in GEDI model fitting.
#'
#' @param a First vector (length m)
#' @param b Second vector (length n)
#'
#' @return Dense matrix of dimensions (m x n) containing the outer product
#'
#' @details
#' Uses BLAS-optimized operations for efficient computation.
#' Equivalent to R's \code{a \%*\% t(b)}.
#'
#' @keywords internal
#' @noRd
VecVecProduct <- function(a, b) {
    .Call(`_gedi_VecVecProduct`, a, b)
}

#' Dense Matrix-Vector Product
#'
#' Computes the product of a dense matrix A and vector b: A * b.
#' Returns the result as a column vector.
#'
#' @param A Dense matrix (m x n)
#' @param b Vector of length n
#'
#' @return Vector of length m containing the product A * b
#'
#' @details
#' Uses BLAS level-2 optimized matrix-vector multiplication.
#' Equivalent to R's \code{A \%*\% b}.
#'
#' @keywords internal
#' @noRd
MatVecProduct <- function(A, b) {
    .Call(`_gedi_MatVecProduct`, A, b)
}

#' Sparse Matrix-Vector Product
#'
#' Computes the product of a sparse matrix A and vector b: A * b.
#' Efficiently handles sparse matrices by only operating on non-zero elements.
#'
#' @param A Sparse matrix (m x n)
#' @param b Vector of length n
#'
#' @return Vector of length m containing the product A * b
#'
#' @details
#' Optimized for sparse matrices, avoiding unnecessary multiplications by zero.
#' Useful for large-scale single-cell data where most entries are zero.
#'
#' @keywords internal
#' @noRd
eigenSparseMatVecProduct <- function(A, b) {
    .Call(`_gedi_eigenSparseMatVecProduct`, A, b)
}

#' Compute Library-Size Normalized Count Matrix (Sparse)
#'
#' Normalizes sparse count matrix M by dividing each element by the outer product
#' of J_vec and s_0. This is equivalent to Mp = M / (J_vec * s_0^T).
#'
#' @param M Sparse raw count matrix (genes x cells)
#' @param J_vec Vector of ones with length J (number of genes)
#' @param s_0 Vector of cell-specific scaling factors (length N)
#'
#' @return Sparse matrix Mp with normalized counts
#'
#' @details
#' Efficiently iterates through non-zero elements only, preserving sparsity structure.
#' Each M(i,j) is divided by (J_vec(i) * s_0(j)).
#' Used for initializing hyperparameters from raw count data.
#'
#' @keywords internal
#' @noRd
compute_Mp <- function(M, J_vec, s_0) {
    .Call(`_gedi_compute_Mp`, M, J_vec, s_0)
}

#' Compute Cell-Specific Scaling Factors from Counts (Sparse)
#'
#' Calculates column-wise sums of sparse count matrix M for hyperparameter initialization.
#' Computes s_0 = (J_vec^T * M + 0.01) / J, where each element represents the library
#' size (total count) for each cell with a small constant added for numerical stability.
#'
#' @param J_vec Vector of ones with length equal to number of genes (J)
#' @param M Sparse raw count matrix (genes x cells)
#' @param J Number of genes (rows in M)
#'
#' @return Vector of length N (number of cells) containing cell-specific scaling factors
#'
#' @details
#' This is the sparse matrix version used when raw count matrix M is provided.
#' For pre-processed Y matrices, use \code{compute_s_0_dense()} instead.
#' The small constant (0.01) prevents division by zero for cells with very low counts.
#' Uses BLAS-optimized sparse matrix-vector multiplication.
#'
#' @keywords internal
#' @noRd
compute_s_0 <- function(J_vec, M, J) {
    .Call(`_gedi_compute_s_0`, J_vec, M, J)
}

#' Compute Gene-Specific Offsets from Normalized Counts (Sparse)
#'
#' Calculates row-wise sums of library-size normalized sparse matrix Mp for
#' hyperparameter initialization. Computes o_0 = (Mp * N_vec + 1e-5) / N, where
#' each element represents the mean normalized count of a gene across all cells.
#'
#' @param Mp Sparse library-size normalized count matrix (genes x cells)
#' @param N_vec Vector of ones with length N (number of cells)
#' @param N Number of cells (columns in Mp)
#'
#' @return Vector of length J (number of genes) containing gene-specific offsets
#'
#' @details
#' Used in conjunction with \code{compute_s_0()} and \code{compute_Mp()} to initialize
#' hyperparameters o_0 and s_0 from raw count data. The small constant (1e-5) provides
#' numerical stability for genes with very low expression.
#' Uses BLAS-optimized sparse matrix-vector multiplication.
#'
#' @keywords internal
#' @noRd
compute_o_0 <- function(Mp, N_vec, N) {
    .Call(`_gedi_compute_o_0`, Mp, N_vec, N)
}

